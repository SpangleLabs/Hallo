# ircbot.py
# Ben Pringle
#
# A superclass designed for making Internet Relay Chat bots using Python.
# Extend it and define new methods for added function!

import socket, time, os, sys, thread

endl = '\r\n' # constant for ease/readability

class ircbot:
    
    def init(self):
        pass # override this method to do any startup code

    def on_join(self, client, channel):
        pass # override this method to handle JOIN events from other users

    def on_part(self, client, channel):
        pass # override this method to handle PART events from other users
    
    def on_mode(self, client, channel, mode, args):
        pass # override this method to handle MODE changes

    def on_pm(self, client, destination, message, found):
        pass # override this method to handle messages alternately

    def raw_data(self, data, unhandled):
        pass # override this method to do general data handling

    def __init__(self):
        # connect
        self.irc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.init()

    def close(self):
        # disconnect
        self.open = False
        self.irc.send('QUIT' + endl)
        self.irc.close()

    def say(self, msg, destination):
        # if the connection is open...
        if not self.open: return
        # send the message, accounting for linebreaks
        for n, line in enumerate(msg.split('\n')):
            self.irc.send('PRIVMSG ' + destination + ' :' + line + endl)
            if(self.logging): self.addlog(self.timestamp() + ' <' + self.nick + '>: ' + line, destination)
            # avoid flooding
            if n % 5 == 0: time.sleep(2)

    def op(self, client):
        # check if someone has op for this bot
        return len(self.ops) == 0 or self.ops.count(client) > 0

    def fn_join(self, args, client):
        'Join a channel.  Use "join <channel>".  Requires op'
        if(self.op(client)):
            if not args in self.channels:
                self.channels.append(args)
            self.irc.send('JOIN ' + args + endl)
            return 'Joined ' + args + '.'
        else:
            return 'Insufficient privileges to join.'

    def fn_part(self, args, client):
        'Leave a channel.  Use "part <channel>".  Requires op'
        if(self.op(client)):
            if args in self.channels:
                self.channels.remove(args)
            self.irc.send('PART ' + args + endl)
            return 'Parted ' + args + '.'
        else:
            return 'Insufficient privileges to part.'

    def fn_quit(self, args, client):
        'Quit IRC.  Use "quit".  Requires op.'
        if(self.op(client)):
            self.close()
            sys.exit(0)
        else:
            return 'Insufficient privileges to quit.'

    def fn_help(self, args, client):
        'Gives information about commands.  Use "help commands" for a list of commands, or "help <command>" for help on a specific command.'
        try: return getattr(self, 'fn_' + args).__doc__ or 'No doc defined.'
        except: pass
        if args == 'commands':
            cmds = []
            # loop through all bot methods
            for fn in dir(self):
                # use the one they're asking about
                if callable(getattr(self, fn)) and fn.startswith('fn_') and (args == 'commands' or 'fn_' + args == fn):
                    cmds.append(fn)
            return ', '.join(cmd[3:] for cmd in cmds)
        else:
            return 'Use "help commands" for a list of commands, or "help <command>" for help on a specific command.  Note:  <>s mean you should replace them with an argument, described within them.  If you are not using private messaging, prefix your commands with "' + self.nick + '".'
    
    def addlog(self, msg, destination):
        # log a message for future reference
        nick = self.nick
        try: os.mkdir('/var/www/Hallo-logs/')
        except: pass
        try: os.mkdir('/var/www/Hallo-logs/' + self.network)
        except: pass
        try: os.mkdir('/var/www/Hallo-logs/' + self.network + '/' + destination)
        except: pass
        # date is the file name
        date = str(time.gmtime()[1]) + '-' + str(time.gmtime()[2]) + '-' + str(time.gmtime()[0])
        # open and write the message
        log = open('/var/www/Hallo-logs/' + self.network + '/' + destination + '/' + date + '.txt', 'a')
        log.write(msg + '\n')
        log.close()
        
    def timestamp(self):
        # return the timestamp, e.g. [05:21:42]
        return '[' + str(time.gmtime()[3]).rjust(2, '0') + ':' + str(time.gmtime()[4]).rjust(2, '0') + ':' + str(time.gmtime()[5]).rjust(2, '0') + ']'
    
    def parse(self, data):
        # take a line of data from the irc socket and process it
        irc = self.irc
        nick = self.nick
        unhandled = False
        # return pings so we don't get timed out
        if 'PING' in data:
            print self.timestamp() + ' PING'
            irc.send('PONG ' + data.split()[1] + endl)
        elif 'PRIVMSG' in data:
            message = ':'.join(data.split(':')[2:]).replace(endl, '').lower()
            # parse out the sender
            client = data.split('!')[0].replace(':', '').lower()
            # parse out where the data came from (e.g. channel message, pm)
            destination = ''.join(data.split(':')[:2]).split(' ')[-2]
            # test for private message
            pm = destination == nick
            # test for public command
            pub = not pm and message.find(nick.lower()) == 0
            found = False
            # print and log a clean version of the message
            print self.timestamp() + ' ' + destination + ' <' + client + '> ' + message
            if(self.logging): self.addlog(self.timestamp() + ' <' + client + '> ' + message, pm and client or destination)
            # if it's a private message, answer to the client, not self
            if pm:
                destination = client
            # if it's a public message, parse out the prefixed nick
            if pub:
                message = message[len(nick):]
                if message.find(':') == 0: message = message[2:]
                while message.find(' ') == 0: message = message[1:]
            # now handle functions!
            if pub or pm:
                function = message.split(' ')[0]
                args = message[len(function):]
                # parse out leading whitespace
                while args.find(' ') == 0: args = args[1:]
                # encase functions in error handling, because users ignore
                # instructions too often :P
                try:
                    for fn in dir(self):
                        if fn == ('fn_' + function.lower()):
                            method = getattr(self, fn)
                            if(callable(method)):
                                out = method(args, client)
                                print self.timestamp() + ' ' + destination + ' <' + self.nick + '> ' + out
                                self.say(out, destination)
                                found = True
                                break
                    # if we can't handle the function, let them know
                    if not found and self.open: self.say('"' + function + '" not defined.  Try "/msg ' + nick + ' help commands" for a list of commands.', destination)
                except Exception, e:
                    # if we have an error, let them know and print it to the screen
                    if self.open: self.say('Error occured.  Try "/msg ' + nick + ' help"', destination)
                    print 'ERROR: ' + str(e)
                # let users define extra code in addition to function stuff
                self.on_pm(client, pm and self.nick or destination, ':'.join(data.split(':')[2:]).replace(endl, '').lower(), found)
        elif 'JOIN' in data:
            # handle JOIN events
            channel = ':'.join(data.split(':')[2:]).replace(endl, '').lower()
            client = data.split('!')[0].replace(':', '').lower()
            print client + ' joined ' + channel
            self.on_join(client, channel)
        elif 'PART' in data:
            # handle PART events
            channel = ':'.join(data.split(':')[2:]).replace(endl, '').lower()
            client = data.split('!')[0].replace(':', '').lower()
            print client + ' left ' + channel
            self.on_part(client, channel)
        elif 'MODE' in data:
            # handle MODE events
            channel = data.split()[2].replace(endl, '').lower()
            client = data.split('!')[0].replace(':', '').lower()
            mode = data.split()[3].replace(endl, '').lower()
            args = ''
            try:
                args = ' '.join(data.split()[4:]).replace(endl, '').lower()
            except:
                pass
            print client + ' set ' + mode + ' ' + args + ' on ' + channel
            self.on_mode(client, channel, mode, args)
        elif not data.replace(endl, '').isspace():
            # if not handled, be confused ^_^
            unhandled = True
            print 'Unhandled data: ' + data
        self.raw_data(data, unhandled)

    def run(self, network, nick, channels, pwd='', ops=[], logging=True, port=6667):
        # begin the bot's infinite loop!
        
        # define class variables
        self.ops = ops
        self.logging = logging
        self.nick = nick
        self.network = network
        self.channels = channels
        irc = self.irc
        irc.connect((network, port))
        self.open = True
        def set():
            time.sleep(15)
            irc.send('NICK ' + nick + endl)
            irc.send('USER PyBot PyHost PyServer :an automated Python IRC bot\r\n')
            for channel in channels:
                irc.send('JOIN ' + channel + endl)
            if pwd: self.say('IDENTIFY ' + pwd, 'NickServ')
        thread.start_new(set, ())
        while True:
            if self.open:
                data = irc.recv(4096)
                for bit in data.split(endl):
                     if not bit.isspace():
                        thread.start_new(self.parse, (bit,))
            
if __name__ == '__main__':
    ircbot().run(raw_input('network: '), raw_input('nick: '), [raw_input('channel: ')])
